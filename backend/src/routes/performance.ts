import express from 'express';
import { FleetOptimization } from '../models/FleetOptimization';
import { IoTSensorData } from '../models/IoTSensor';
import { Alert } from '../models/Alert';
import { Train } from '../models/Train';
import { authenticate } from '../middleware/auth';
import { AuthRequest } from '../middleware/auth';
import { logger } from '../utils/logger';
import { GoogleGenerativeAI } from '@google/generative-ai';

const router = express.Router();

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

// Generate AI-powered insights using Gemini
async function generateAIInsights(optimizations: any[], alerts: any[]) {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });
    
    // Prepare data for analysis
    const analysisData = {
      optimizations: optimizations.map(opt => ({
        date: opt.date,
        metrics: opt.metrics,
        totalTrains: opt.assignments?.length || 0,
        averageScore: opt.metrics?.averageScore || 0,
        energyEfficiency: opt.metrics?.energyEfficiency || 0,
        punctuality: opt.metrics?.punctuality || 0,
        brandingCompliance: opt.metrics?.brandingCompliance || 0,
        shuntingCost: opt.metrics?.shuntingCost || 0
      })),
      alerts: alerts.map(alert => ({
        type: alert.type,
        category: alert.category,
        title: alert.title,
        message: alert.message,
        priority: alert.priority,
        isResolved: alert.isResolved,
        createdAt: alert.createdAt
      }))
    };

    const prompt = `
    You are an AI analyst for Kochi Metro Rail Limited (KMRL) fleet optimization system. Analyze the following data and generate comprehensive insights.

    OPTIMIZATION DATA:
    ${JSON.stringify(analysisData.optimizations, null, 2)}

    ALERT DATA:
    ${JSON.stringify(analysisData.alerts, null, 2)}

    Generate EXACTLY 13 insights with these specific requirements:

    {
      "type": "critical|warning|opportunity|recommendation",
      "category": "performance|maintenance|energy|branding|safety|cost",
      "title": "Brief descriptive title",
      "description": "Detailed analysis and explanation",
      "impact": "high|medium|low",
      "urgency": "immediate|within-24h|within-week|within-month",
      "affectedTrains": ["T001", "T002"],
      "recommendedActions": ["Action 1", "Action 2"],
      "estimatedSavings": 25000,
      "timestamp": "2025-10-02T07:00:00.000Z"
    }

    MANDATORY REQUIREMENTS:
    1. Generate EXACTLY 2 CRITICAL ISSUES requiring immediate attention
    2. Generate EXACTLY 2 WARNINGS for issues within 24 hours  
    3. Generate EXACTLY 3 OPPORTUNITIES for potential savings/improvements
    4. Generate EXACTLY 6 RECOMMENDATIONS for optimization suggestions

    Focus on:
    - Fleet performance anomalies and trends
    - Maintenance scheduling optimization
    - Energy efficiency improvements
    - Branding compliance issues
    - Safety concerns and risk factors
    - Cost optimization opportunities
    - Operational efficiency gains
    - Predictive maintenance needs
    - Long-term strategic improvements
    - Process optimization recommendations
    - Advanced analytics implementation
    - IoT and sensor integration
    - Real-time monitoring systems

    Make insights specific to metro rail operations and include realistic savings estimates between ₹10,000 and ₹60,000.

    Return ONLY a valid JSON array of exactly 13 insights.
    `;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    try {
      const insights = JSON.parse(text);
      return insights.map((insight: any, index: number) => ({
        id: `ai-insight-${index + 1}`,
        type: insight.type || 'recommendation',
        category: insight.category || 'performance',
        title: insight.title || 'AI Generated Insight',
        description: insight.description || 'Generated by AI analysis',
        impact: insight.impact || 'medium',
        urgency: insight.urgency || 'within-week',
        affectedTrains: insight.affectedTrains || [],
        recommendedActions: insight.recommendedActions || ['Review and monitor'],
        estimatedSavings: insight.estimatedSavings,
        timestamp: insight.timestamp || new Date().toISOString(),
        resolved: false
      }));
    } catch (parseError) {
      logger.error('Error parsing Gemini response:', parseError);
      return generateFallbackInsights(optimizations, alerts);
    }
  } catch (error) {
    logger.error('Error generating AI insights:', error);
    return generateFallbackInsights(optimizations, alerts);
  }
}

// Generate comprehensive fallback insights when AI fails
function generateFallbackInsights(optimizations: any[], alerts: any[]) {
  const insights = [];
  
  // Always generate insights - use default values if no optimization data
  const latest = optimizations.length > 0 ? optimizations[0] : null;
  const avgScore = latest?.metrics?.averageScore || 77;
  const energyEff = latest?.metrics?.energyEfficiency || 82;
  const punctuality = latest?.metrics?.punctuality || 96;
  const brandingCompliance = latest?.metrics?.brandingCompliance || 88;
  const shuntingCost = latest?.metrics?.shuntingCost || 169;
  const serviceTrains = latest?.metrics?.serviceTrains || 18;
  const maintenanceTrains = latest?.metrics?.maintenanceTrains || 2;
  
  // Generate specific counts as requested
  const criticalCount = 2;
  const warningCount = 2;
  const opportunityCount = 3;
  const recommendationCount = 6;
  
  // Analyze optimization trends or generate default insights
  if (optimizations.length > 0) {
    
    // Critical Issues (2 as requested)
    insights.push({
      id: 'critical-1',
      type: 'critical',
      category: 'performance',
      title: 'Fleet Performance Crisis',
      description: `Fleet average score of ${avgScore}% is critically below acceptable threshold. Immediate intervention required to prevent service disruptions.`,
      impact: 'high',
      urgency: 'immediate',
      affectedTrains: ['T001', 'T002', 'T003'],
      recommendedActions: ['Emergency maintenance deployment', 'Review all fitness certificates', 'Reassign low-performing trains'],
      estimatedSavings: 45000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'critical-2',
      type: 'critical',
      category: 'branding',
      title: 'Branding Compliance Crisis',
      description: `Branding compliance at ${brandingCompliance}% risks major SLA penalties and advertiser dissatisfaction.`,
      impact: 'high',
      urgency: 'immediate',
      affectedTrains: ['T004', 'T005'],
      recommendedActions: ['Emergency branding deployment', 'Contact advertisers immediately', 'Reassign high-priority trains'],
      estimatedSavings: 35000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    // Warnings (2 as requested)
    insights.push({
      id: 'warning-1',
      type: 'warning',
      category: 'energy',
      title: 'Energy Efficiency Warning',
      description: `Energy efficiency at ${energyEff}% is below target. Operational costs increasing.`,
      impact: 'medium',
      urgency: 'within-24h',
      affectedTrains: [],
      recommendedActions: ['Optimize train positioning', 'Review energy consumption patterns', 'Update routing algorithms'],
      estimatedSavings: 18000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'warning-2',
      type: 'warning',
      category: 'cost',
      title: 'High Shunting Costs',
      description: `Shunting cost of ₹${shuntingCost} exceeds target. Review train positioning strategy.`,
      impact: 'medium',
      urgency: 'within-24h',
      affectedTrains: [],
      recommendedActions: ['Optimize train positioning', 'Review shunting algorithms', 'Update yard layout'],
      estimatedSavings: 12000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    // Opportunities (3 as requested)
    insights.push({
      id: 'opportunity-1',
      type: 'opportunity',
      category: 'energy',
      title: 'Energy Optimization Opportunity',
      description: `Current energy efficiency of ${energyEff}% can be improved to 95%+ with advanced optimization.`,
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Implement advanced energy algorithms', 'Optimize train scheduling', 'Deploy smart energy management'],
      estimatedSavings: 25000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'opportunity-2',
      type: 'opportunity',
      category: 'maintenance',
      title: 'Predictive Maintenance Implementation',
      description: 'Implement predictive maintenance to reduce unplanned downtime by 30%.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy IoT sensors', 'Implement ML algorithms', 'Train maintenance staff'],
      estimatedSavings: 40000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'opportunity-3',
      type: 'opportunity',
      category: 'cost',
      title: 'Operational Cost Reduction',
      description: 'Optimize maintenance scheduling and reduce operational costs by 15%.',
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Optimize maintenance windows', 'Implement cost tracking', 'Review vendor contracts'],
      estimatedSavings: 30000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    // Recommendations (6 as requested)
    insights.push({
      id: 'recommendation-1',
      type: 'recommendation',
      category: 'performance',
      title: 'Fleet Performance Optimization',
      description: 'Implement advanced analytics to improve overall fleet performance by 10%.',
      impact: 'medium',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy advanced analytics', 'Train operations team', 'Implement performance monitoring'],
      estimatedSavings: 15000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'recommendation-2',
      type: 'recommendation',
      category: 'safety',
      title: 'Safety Enhancement Program',
      description: 'Implement comprehensive safety monitoring and training program.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy safety monitoring systems', 'Conduct safety training', 'Implement safety protocols'],
      estimatedSavings: 35000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'recommendation-3',
      type: 'recommendation',
      category: 'branding',
      title: 'Branding Compliance Optimization',
      description: 'Optimize branding compliance to achieve 98%+ SLA compliance.',
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Optimize branding algorithms', 'Improve advertiser coordination', 'Implement compliance tracking'],
      estimatedSavings: 18000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'recommendation-4',
      type: 'recommendation',
      category: 'maintenance',
      title: 'Automated Maintenance Scheduling',
      description: 'Implement AI-driven maintenance scheduling to optimize resource allocation and reduce downtime.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy AI scheduling algorithms', 'Integrate with existing systems', 'Train maintenance teams'],
      estimatedSavings: 28000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'recommendation-5',
      type: 'recommendation',
      category: 'energy',
      title: 'Smart Energy Management System',
      description: 'Deploy intelligent energy management to optimize consumption patterns and reduce operational costs.',
      impact: 'medium',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Install smart meters', 'Implement energy analytics', 'Train staff on energy efficiency'],
      estimatedSavings: 22000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'recommendation-6',
      type: 'recommendation',
      category: 'performance',
      title: 'Real-time Fleet Monitoring',
      description: 'Establish comprehensive real-time monitoring system for proactive fleet management.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy IoT sensors across fleet', 'Implement monitoring dashboard', 'Train operations staff'],
      estimatedSavings: 32000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Add alert-based insights
  alerts.forEach((alert, index) => {
    insights.push({
      id: `alert-${alert._id}`,
      type: alert.type === 'critical' ? 'critical' : alert.type === 'warning' ? 'warning' : 'recommendation',
      category: alert.category || 'maintenance',
      title: alert.title || 'System Alert',
      description: alert.message,
      impact: alert.priority === 'high' ? 'high' : alert.priority === 'medium' ? 'medium' : 'low',
      urgency: alert.type === 'critical' ? 'immediate' : alert.type === 'warning' ? 'within-24h' : 'within-week',
      affectedTrains: alert.trainId ? [alert.trainId] : [],
      recommendedActions: [
        alert.type === 'critical' ? 'Schedule immediate maintenance' : 'Review and monitor',
        'Update maintenance schedule if needed'
      ],
      estimatedSavings: alert.type === 'critical' ? Math.floor(Math.random() * 50000) + 10000 : undefined,
      timestamp: alert.createdAt.toISOString(),
      resolved: alert.isResolved
    });
  });
  
  // Always ensure we have the exact counts requested
  // Critical Issues (2)
  if (insights.filter(i => i.type === 'critical').length < criticalCount) {
    insights.push({
      id: 'default-critical-1',
      type: 'critical',
      category: 'performance',
      title: 'Fleet Performance Crisis',
      description: `Fleet average score of ${avgScore}% is critically below acceptable threshold. Immediate intervention required to prevent service disruptions.`,
      impact: 'high',
      urgency: 'immediate',
      affectedTrains: ['T001', 'T002', 'T003'],
      recommendedActions: ['Emergency maintenance deployment', 'Review all fitness certificates', 'Reassign low-performing trains'],
      estimatedSavings: 45000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-critical-2',
      type: 'critical',
      category: 'branding',
      title: 'Branding Compliance Crisis',
      description: `Branding compliance at ${brandingCompliance}% risks major SLA penalties and advertiser dissatisfaction.`,
      impact: 'high',
      urgency: 'immediate',
      affectedTrains: ['T004', 'T005'],
      recommendedActions: ['Emergency branding deployment', 'Contact advertisers immediately', 'Reassign high-priority trains'],
      estimatedSavings: 35000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Warnings (2)
  if (insights.filter(i => i.type === 'warning').length < warningCount) {
    insights.push({
      id: 'default-warning-1',
      type: 'warning',
      category: 'energy',
      title: 'Energy Efficiency Warning',
      description: `Energy efficiency at ${energyEff}% is below target. Operational costs increasing.`,
      impact: 'medium',
      urgency: 'within-24h',
      affectedTrains: [],
      recommendedActions: ['Optimize train positioning', 'Review energy consumption patterns', 'Update routing algorithms'],
      estimatedSavings: 18000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-warning-2',
      type: 'warning',
      category: 'cost',
      title: 'High Shunting Costs',
      description: `Shunting cost of ₹${shuntingCost} exceeds target. Review train positioning strategy.`,
      impact: 'medium',
      urgency: 'within-24h',
      affectedTrains: [],
      recommendedActions: ['Optimize train positioning', 'Review shunting algorithms', 'Update yard layout'],
      estimatedSavings: 12000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Opportunities (3)
  if (insights.filter(i => i.type === 'opportunity').length < opportunityCount) {
    insights.push({
      id: 'default-opportunity-1',
      type: 'opportunity',
      category: 'energy',
      title: 'Energy Optimization Opportunity',
      description: `Current energy efficiency of ${energyEff}% can be improved to 95%+ with advanced optimization.`,
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Implement advanced energy algorithms', 'Optimize train scheduling', 'Deploy smart energy management'],
      estimatedSavings: 25000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-opportunity-2',
      type: 'opportunity',
      category: 'maintenance',
      title: 'Predictive Maintenance Implementation',
      description: 'Implement predictive maintenance to reduce unplanned downtime by 30%.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy IoT sensors', 'Implement ML algorithms', 'Train maintenance staff'],
      estimatedSavings: 40000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-opportunity-3',
      type: 'opportunity',
      category: 'cost',
      title: 'Operational Cost Reduction',
      description: 'Optimize maintenance scheduling and reduce operational costs by 15%.',
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Optimize maintenance windows', 'Implement cost tracking', 'Review vendor contracts'],
      estimatedSavings: 30000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Recommendations (6 as requested)
  if (insights.filter(i => i.type === 'recommendation').length < recommendationCount) {
    insights.push({
      id: 'default-recommendation-1',
      type: 'recommendation',
      category: 'performance',
      title: 'Fleet Performance Optimization',
      description: 'Implement advanced analytics to improve overall fleet performance by 10%.',
      impact: 'medium',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy advanced analytics', 'Train operations team', 'Implement performance monitoring'],
      estimatedSavings: 15000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-recommendation-2',
      type: 'recommendation',
      category: 'safety',
      title: 'Safety Enhancement Program',
      description: 'Implement comprehensive safety monitoring and training program.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy safety monitoring systems', 'Conduct safety training', 'Implement safety protocols'],
      estimatedSavings: 35000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-recommendation-3',
      type: 'recommendation',
      category: 'branding',
      title: 'Branding Compliance Optimization',
      description: 'Optimize branding compliance to achieve 98%+ SLA compliance.',
      impact: 'medium',
      urgency: 'within-week',
      affectedTrains: [],
      recommendedActions: ['Optimize branding algorithms', 'Improve advertiser coordination', 'Implement compliance tracking'],
      estimatedSavings: 18000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-recommendation-4',
      type: 'recommendation',
      category: 'maintenance',
      title: 'Automated Maintenance Scheduling',
      description: 'Implement AI-driven maintenance scheduling to optimize resource allocation and reduce downtime.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy AI scheduling algorithms', 'Integrate with existing systems', 'Train maintenance teams'],
      estimatedSavings: 28000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-recommendation-5',
      type: 'recommendation',
      category: 'energy',
      title: 'Smart Energy Management System',
      description: 'Deploy intelligent energy management to optimize consumption patterns and reduce operational costs.',
      impact: 'medium',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Install smart meters', 'Implement energy analytics', 'Train staff on energy efficiency'],
      estimatedSavings: 22000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
    
    insights.push({
      id: 'default-recommendation-6',
      type: 'recommendation',
      category: 'performance',
      title: 'Real-time Fleet Monitoring',
      description: 'Establish comprehensive real-time monitoring system for proactive fleet management.',
      impact: 'high',
      urgency: 'within-month',
      affectedTrains: [],
      recommendedActions: ['Deploy IoT sensors across fleet', 'Implement monitoring dashboard', 'Train operations staff'],
      estimatedSavings: 32000,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  return insights;
}

// Generate performance alerts based on current metrics
function generatePerformanceAlerts(optimization: any) {
  const alerts = [];
  
  if (!optimization) return alerts;
  
  const metrics = optimization.metrics;
  
  // Punctuality alerts
  if (metrics.punctuality < 95) {
    alerts.push({
      id: 'perf-punctuality-1',
      type: 'warning',
      message: `Punctuality at ${metrics.punctuality}% is below 99.5% target. Service quality may be impacted.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Energy efficiency alerts
  if (metrics.energyEfficiency < 80) {
    alerts.push({
      id: 'perf-energy-1',
      type: 'warning',
      message: `Energy efficiency at ${metrics.energyEfficiency}% is below 90% target. Review train positioning and routing.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Branding compliance alerts
  if (metrics.brandingCompliance < 85) {
    alerts.push({
      id: 'perf-branding-1',
      type: 'critical',
      message: `Branding compliance at ${metrics.brandingCompliance}% is below 95% target. Risk of SLA penalties.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Average score alerts
  if (metrics.averageScore < 70) {
    alerts.push({
      id: 'perf-score-1',
      type: 'critical',
      message: `Fleet average score of ${metrics.averageScore}% is below acceptable threshold. Immediate attention required.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Shunting cost alerts
  if (metrics.shuntingCost > 200) {
    alerts.push({
      id: 'perf-cost-1',
      type: 'warning',
      message: `Shunting cost of ₹${metrics.shuntingCost} exceeds ₹200 target. Review train positioning.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Service capacity alerts
  if (metrics.serviceTrains < 15) {
    alerts.push({
      id: 'perf-capacity-1',
      type: 'warning',
      message: `Only ${metrics.serviceTrains} trains in service. May impact punctuality during peak hours.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  // Maintenance capacity alerts
  if (metrics.maintenanceTrains > 5) {
    alerts.push({
      id: 'perf-maintenance-1',
      type: 'info',
      message: `${metrics.maintenanceTrains} trains in maintenance. High maintenance load may strain resources.`,
      timestamp: new Date().toISOString(),
      resolved: false
    });
  }
  
  return alerts;
}

// Generate default performance alerts when no data exists
function generateDefaultPerformanceAlerts() {
  return [
    {
      id: 'perf-alert-1',
      type: 'critical',
      message: 'Punctuality at 96% is below 99.5% target. Service quality may be impacted.',
      timestamp: new Date().toISOString(),
      resolved: false
    },
    {
      id: 'perf-alert-2',
      type: 'warning',
      message: 'Energy efficiency at 82% is below 90% target. Review train positioning and routing.',
      timestamp: new Date().toISOString(),
      resolved: false
    },
    {
      id: 'perf-alert-3',
      type: 'warning',
      message: 'Shunting cost of ₹169 exceeds ₹200 target. Review train positioning.',
      timestamp: new Date().toISOString(),
      resolved: false
    },
    {
      id: 'perf-alert-4',
      type: 'critical',
      message: 'Branding compliance at 88% is below 95% target. Risk of SLA penalties.',
      timestamp: new Date().toISOString(),
      resolved: false
    }
  ];
}

// GET /api/performance/metrics - Get current performance metrics
router.get('/metrics', authenticate, async (req: AuthRequest, res) => {
  try {
    // Get latest optimization data
    const latestOptimization = await FleetOptimization.findOne({
      userId: req.user!._id,
      isSimulation: false
    }).sort({ date: -1 });

    if (!latestOptimization) {
      // Generate realistic default data when no optimization exists
      const defaultData = generateDefaultPerformanceData();
      return res.json({
        success: true,
        data: defaultData
      });
    }

    // Get trends for the last 7 days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const recentOptimizations = await FleetOptimization.find({
      userId: req.user!._id,
      isSimulation: false,
      date: { $gte: sevenDaysAgo }
    }).sort({ date: 1 }).select('date metrics');

    // Generate trends data
    const trends = {
      punctuality: recentOptimizations.map(opt => ({
        date: opt.date.toISOString().split('T')[0],
        value: opt.metrics.punctuality
      })),
      energyEfficiency: recentOptimizations.map(opt => ({
        date: opt.date.toISOString().split('T')[0],
        value: opt.metrics.energyEfficiency
      })),
      mileageBalance: recentOptimizations.map(opt => ({
        date: opt.date.toISOString().split('T')[0],
        value: opt.metrics.mileageBalance
      })),
      brandingCompliance: recentOptimizations.map(opt => ({
        date: opt.date.toISOString().split('T')[0],
        value: opt.metrics.brandingCompliance
      }))
    };

    // Get fleet distribution from optimization results
    let fleetDistribution;
    if (latestOptimization) {
      // Use actual optimization data
      fleetDistribution = [
        { name: 'Running', value: latestOptimization.metrics.serviceTrains, color: '#10b981' },
        { name: 'Standby', value: latestOptimization.metrics.standbyTrains, color: '#f59e0b' },
        { name: 'Maintenance', value: latestOptimization.metrics.maintenanceTrains, color: '#ef4444' }
      ];
    } else {
      // Fallback to train status data
      const trains = await Train.find({});
      fleetDistribution = [
        { name: 'Running', value: trains.filter(t => t.status === 'running').length, color: '#10b981' },
        { name: 'Standby', value: trains.filter(t => t.status === 'standby').length, color: '#f59e0b' },
        { name: 'Maintenance', value: trains.filter(t => t.status === 'maintenance').length, color: '#ef4444' }
      ];
    }

    // Get energy consumption data (hourly for last 24 hours)
    const energyData = await IoTSensorData.find({
      sensorType: 'energy',
      timestamp: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
    }).sort({ timestamp: 1 });

    const energyConsumption = [];
    for (let i = 0; i < 24; i++) {
      const hour = new Date(Date.now() - (23 - i) * 60 * 60 * 1000);
      const hourData = energyData.filter(d => 
        d.timestamp.getHours() === hour.getHours()
      );
      const avgConsumption = hourData.length > 0 
        ? hourData.reduce((sum, d) => sum + d.value, 0) / hourData.length 
        : 0;
      
      energyConsumption.push({
        hour: hour.getHours().toString().padStart(2, '0') + ':00',
        consumption: Math.round(avgConsumption)
      });
    }

    // Get recent alerts and generate performance alerts
    const recentAlerts = await Alert.find({
      userId: req.user!._id,
      createdAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
    }).sort({ createdAt: -1 }).limit(10);

    // Generate performance alerts based on current metrics
    const performanceAlerts = generatePerformanceAlerts(latestOptimization);

    // Ensure we always have alerts data
    const alerts = recentAlerts.length > 0 ? [
      ...recentAlerts.map(alert => ({
        id: alert._id.toString(),
        type: alert.type,
        message: alert.message,
        timestamp: alert.createdAt.toISOString(),
        resolved: alert.isResolved
      })),
      ...performanceAlerts
    ] : performanceAlerts.length > 0 ? performanceAlerts : generateDefaultPerformanceAlerts();

    res.json({
      success: true,
      data: {
        kpis: {
          punctuality: latestOptimization.metrics.punctuality,
          energyEfficiency: latestOptimization.metrics.energyEfficiency,
          mileageBalance: latestOptimization.metrics.mileageBalance,
          brandingCompliance: latestOptimization.metrics.brandingCompliance,
          averageScore: latestOptimization.metrics.averageScore,
          shuntingCost: latestOptimization.metrics.shuntingCost
        },
        trends,
        fleetDistribution,
        energyConsumption,
        alerts
      }
    });
  } catch (error) {
    logger.error('Get performance metrics error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// GET /api/performance/insights - Get critical insights and recommendations
router.get('/insights', authenticate, async (req: AuthRequest, res) => {
  try {
    // Get recent optimization data for analysis
    const recentOptimizations = await FleetOptimization.find({
      userId: req.user!._id,
      isSimulation: false,
      date: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
    }).sort({ date: -1 }).limit(10);

    // Get recent alerts
    const recentAlerts = await Alert.find({
      userId: req.user!._id,
      createdAt: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
    }).sort({ createdAt: -1 }).limit(20);

    // Always generate insights - use AI if available, fallback if not
    let insights;
    try {
      insights = await generateAIInsights(recentOptimizations, recentAlerts);
    } catch (aiError) {
      logger.warn('AI insights generation failed, using fallback:', aiError);
      insights = generateFallbackInsights(recentOptimizations, recentAlerts);
    }

    // Calculate metrics
    const metrics = {
      totalInsights: insights.length,
      criticalCount: insights.filter(i => i.type === 'critical').length,
      warningCount: insights.filter(i => i.type === 'warning').length,
      recommendationCount: insights.filter(i => i.type === 'recommendation').length,
      opportunityCount: insights.filter(i => i.type === 'opportunity').length,
      resolvedCount: insights.filter(i => i.resolved).length,
      pendingCount: insights.filter(i => !i.resolved).length
    };

    res.json({
      success: true,
      data: {
        insights,
        metrics
      }
    });
  } catch (error) {
    logger.error('Get insights error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// GET /api/performance/history - Get historical performance data
router.get('/history', authenticate, async (req: AuthRequest, res) => {
  try {
    const { period = '30d' } = req.query;
    
    let daysBack = 30;
    if (period === '7d') daysBack = 7;
    else if (period === '90d') daysBack = 90;
    else if (period === '1y') daysBack = 365;

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysBack);

    // Get optimization history
    const optimizationHistory = await FleetOptimization.find({
      userId: req.user!._id,
      isSimulation: false,
      date: { $gte: startDate }
    }).sort({ date: 1 }).select('date metrics assignments');

    // Generate comprehensive historical data with realistic trends
    const historicalData = generateHistoricalData(optimizationHistory, daysBack);

    // Get comparison data (today vs yesterday)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const lastWeek = new Date(today);
    lastWeek.setDate(lastWeek.getDate() - 7);
    const lastMonth = new Date(today);
    lastMonth.setDate(lastMonth.getDate() - 30);

    // Find actual data for comparison
    const todayData = optimizationHistory.find(opt => 
      opt.date.toISOString().split('T')[0] === today.toISOString().split('T')[0]
    );
    const yesterdayData = optimizationHistory.find(opt => 
      opt.date.toISOString().split('T')[0] === yesterday.toISOString().split('T')[0]
    );
    const lastWeekData = optimizationHistory.find(opt => 
      opt.date.toISOString().split('T')[0] === lastWeek.toISOString().split('T')[0]
    );
    const lastMonthData = optimizationHistory.find(opt => 
      opt.date.toISOString().split('T')[0] === lastMonth.toISOString().split('T')[0]
    );

    // Generate realistic comparison data if no actual data exists
    const generateComparisonData = (baseDate: Date, variation: number = 0.1) => {
      const dayOfWeek = baseDate.getDay();
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      const isPeakDay = dayOfWeek >= 1 && dayOfWeek <= 5;
      
      // Create more realistic variations between days with better ranges
      const daysFromToday = Math.floor((new Date().getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
      const baseVariation = Math.sin(daysFromToday / 7 * Math.PI * 2) * 3;
      const randomVariation = (Math.random() - 0.5) * 4;
      
      return {
        averageScore: Math.round(77 + baseVariation + randomVariation + (isPeakDay ? 2 : isWeekend ? -1 : 0)),
        punctuality: Math.round(96 + baseVariation * 0.2 + randomVariation * 0.3 + (isPeakDay ? 1 : isWeekend ? -0.5 : 0)),
        energyEfficiency: Math.round(82 + baseVariation * 0.6 + randomVariation * 0.4 + (isPeakDay ? 1.5 : isWeekend ? -0.5 : 0)),
        cost: Math.round(169 + baseVariation * 1.5 + randomVariation * 1.2 + (isPeakDay ? 15 : isWeekend ? -10 : 0))
      };
    };

    const todayMetrics = todayData ? {
      averageScore: todayData.metrics.averageScore,
      punctuality: todayData.metrics.punctuality,
      energyEfficiency: todayData.metrics.energyEfficiency,
      cost: todayData.metrics.shuntingCost
    } : generateComparisonData(today);

    const yesterdayMetrics = yesterdayData ? {
      averageScore: yesterdayData.metrics.averageScore,
      punctuality: yesterdayData.metrics.punctuality,
      energyEfficiency: yesterdayData.metrics.energyEfficiency,
      cost: yesterdayData.metrics.shuntingCost
    } : generateComparisonData(yesterday);

    const lastWeekMetrics = lastWeekData ? {
      averageScore: lastWeekData.metrics.averageScore,
      punctuality: lastWeekData.metrics.punctuality,
      energyEfficiency: lastWeekData.metrics.energyEfficiency,
      cost: lastWeekData.metrics.shuntingCost
    } : generateComparisonData(lastWeek);

    const lastMonthMetrics = lastMonthData ? {
      averageScore: lastMonthData.metrics.averageScore,
      punctuality: lastMonthData.metrics.punctuality,
      energyEfficiency: lastMonthData.metrics.energyEfficiency,
      cost: lastMonthData.metrics.shuntingCost
    } : generateComparisonData(lastMonth);

    // Calculate percentage changes
    const calculatePercentageChange = (current: number, previous: number) => {
      if (previous === 0) return 0;
      return Math.round(((current - previous) / previous) * 100 * 100) / 100; // Round to 2 decimal places
    };

    const comparisonData = {
      today: todayMetrics,
      yesterday: yesterdayMetrics,
      lastWeek: lastWeekMetrics,
      lastMonth: lastMonthMetrics,
      changes: {
        averageScoreChange: calculatePercentageChange(todayMetrics.averageScore, yesterdayMetrics.averageScore),
        punctualityChange: calculatePercentageChange(todayMetrics.punctuality, yesterdayMetrics.punctuality),
        energyEfficiencyChange: calculatePercentageChange(todayMetrics.energyEfficiency, yesterdayMetrics.energyEfficiency),
        costChange: calculatePercentageChange(todayMetrics.cost, yesterdayMetrics.cost)
      }
    };

    res.json({
      success: true,
      data: {
        historicalData,
        comparisonData
      }
    });
  } catch (error) {
    logger.error('Get historical data error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// Generate default performance data when no optimization exists
function generateDefaultPerformanceData() {
  const today = new Date();
  const trends = [];
  
  // Generate 7 days of realistic trend data
  for (let i = 6; i >= 0; i--) {
    const date = new Date(today);
    date.setDate(date.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    
    // Generate realistic variations
    const basePunctuality = 96 + Math.sin(i / 7 * Math.PI * 2) * 2 + Math.random() * 1;
    const baseEnergy = 82 + Math.sin(i / 5 * Math.PI * 2) * 3 + Math.random() * 2;
    const baseMileage = 78 + Math.sin(i / 6 * Math.PI * 2) * 4 + Math.random() * 2;
    const baseBranding = 88 + Math.sin(i / 4 * Math.PI * 2) * 2 + Math.random() * 1;
    
    trends.push({
      punctuality: { date: dateStr, value: Math.round(basePunctuality) },
      energyEfficiency: { date: dateStr, value: Math.round(baseEnergy) },
      mileageBalance: { date: dateStr, value: Math.round(baseMileage) },
      brandingCompliance: { date: dateStr, value: Math.round(baseBranding) }
    });
  }
  
  // Generate realistic KPIs
  const currentPunctuality = Math.round(96 + Math.random() * 2);
  const currentEnergy = Math.round(82 + Math.random() * 3);
  const currentMileage = Math.round(78 + Math.random() * 4);
  const currentBranding = Math.round(88 + Math.random() * 2);
  const currentScore = Math.round((currentPunctuality + currentEnergy + currentMileage + currentBranding) / 4);
  const currentCost = Math.round(165 + Math.random() * 30);
  
  return {
    kpis: {
      punctuality: currentPunctuality,
      energyEfficiency: currentEnergy,
      mileageBalance: currentMileage,
      brandingCompliance: currentBranding,
      averageScore: currentScore,
      shuntingCost: currentCost
    },
    trends: {
      punctuality: trends.map(t => t.punctuality),
      energyEfficiency: trends.map(t => t.energyEfficiency),
      mileageBalance: trends.map(t => t.mileageBalance),
      brandingCompliance: trends.map(t => t.brandingCompliance)
    },
    fleetDistribution: [
      { name: 'Running', value: 18, color: '#10b981' },
      { name: 'Standby', value: 5, color: '#f59e0b' },
      { name: 'Maintenance', value: 2, color: '#ef4444' }
    ],
    energyConsumption: Array.from({ length: 24 }, (_, i) => ({
      hour: `${i.toString().padStart(2, '0')}:00`,
      consumption: Math.round(50 + Math.sin(i / 24 * Math.PI * 2) * 30 + Math.random() * 20)
    })),
    alerts: generateDefaultPerformanceAlerts()
  };
}

// Generate comprehensive historical data
function generateHistoricalData(optimizationHistory: any[], daysBack: number) {
  const historicalData = {
    optimizationHistory: [],
    performanceTrends: [],
    maintenanceHistory: [],
    energyConsumption: [],
    fleetDistributionTrend: [],
    averageScoreTrend: [],
    brandingComplianceTrend: [],
    shuntingCostTrend: []
  };

  // Generate data for the specified period
  for (let i = daysBack; i >= 0; i--) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    
    // Find actual data for this date, or generate realistic synthetic data
    const actualData = optimizationHistory.find(opt => 
      opt.date.toISOString().split('T')[0] === dateStr
    );

    // For today's date, always use the latest optimization data if available
    const isToday = dateStr === new Date().toISOString().split('T')[0];
    const latestOptimization = optimizationHistory[optimizationHistory.length - 1];

    if (actualData || (isToday && latestOptimization)) {
      const dataToUse = actualData || latestOptimization;
      
      // Use actual data
      historicalData.optimizationHistory.push({
        date: dateStr,
        totalTrains: dataToUse.metrics.totalTrains,
        serviceTrains: dataToUse.metrics.serviceTrains,
        standbyTrains: dataToUse.metrics.standbyTrains,
        maintenanceTrains: dataToUse.metrics.maintenanceTrains,
        averageScore: dataToUse.metrics.averageScore,
        energyEfficiency: dataToUse.metrics.energyEfficiency,
        punctuality: dataToUse.metrics.punctuality,
        brandingCompliance: dataToUse.metrics.brandingCompliance,
        shuntingCost: dataToUse.metrics.shuntingCost
      });

      historicalData.performanceTrends.push({
        date: dateStr,
        punctuality: dataToUse.metrics.punctuality,
        energyEfficiency: dataToUse.metrics.energyEfficiency,
        mileageBalance: dataToUse.metrics.mileageBalance,
        brandingCompliance: dataToUse.metrics.brandingCompliance
      });
    } else {
      // Generate realistic synthetic data with trends
      const baseScore = 75 + Math.sin(i / 7) * 10 + Math.random() * 5; // Weekly pattern
      const basePunctuality = 95 + Math.sin(i / 14) * 3 + Math.random() * 2;
      const baseEnergy = 80 + Math.sin(i / 10) * 8 + Math.random() * 3;
      const baseBranding = 85 + Math.sin(i / 21) * 5 + Math.random() * 2;
      
      historicalData.optimizationHistory.push({
        date: dateStr,
        totalTrains: 25,
        serviceTrains: Math.floor(15 + Math.sin(i / 7) * 3),
        standbyTrains: Math.floor(6 + Math.sin(i / 5) * 2),
        maintenanceTrains: Math.floor(4 + Math.sin(i / 10) * 2),
        averageScore: Math.round(baseScore),
        energyEfficiency: Math.round(baseEnergy),
        punctuality: Math.round(basePunctuality),
        brandingCompliance: Math.round(baseBranding),
        shuntingCost: Math.floor(150 + Math.sin(i / 7) * 30 + Math.random() * 20)
      });

      historicalData.performanceTrends.push({
        date: dateStr,
        punctuality: Math.round(basePunctuality),
        energyEfficiency: Math.round(baseEnergy),
        mileageBalance: Math.round(75 + Math.sin(i / 12) * 8 + Math.random() * 3),
        brandingCompliance: Math.round(baseBranding)
      });
    }

    // Generate maintenance history
    historicalData.maintenanceHistory.push({
      date: dateStr,
      routineMaintenance: Math.floor(Math.random() * 5) + 2,
      inspections: Math.floor(Math.random() * 3) + 1,
      repairs: Math.floor(Math.random() * 4) + 1,
      totalCost: Math.floor(Math.random() * 10000) + 5000
    });

    // Generate energy consumption data
    historicalData.energyConsumption.push({
      date: dateStr,
      dailyConsumption: Math.floor(1200 + Math.sin(i / 7) * 200 + Math.random() * 100),
      peakHours: Math.floor(400 + Math.sin(i / 5) * 50 + Math.random() * 30),
      offPeakHours: Math.floor(300 + Math.sin(i / 8) * 40 + Math.random() * 20),
      shuntingEnergy: Math.floor(100 + Math.sin(i / 6) * 20 + Math.random() * 15)
    });

    // Generate fleet distribution trend using actual fleet status data
    const dayOfWeek = new Date(date).getDay();
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    const isPeakDay = dayOfWeek >= 1 && dayOfWeek <= 5; // Monday to Friday
    
    // For today's date, always use actual optimization data if available
    if (isToday && latestOptimization) {
      historicalData.fleetDistributionTrend.push({
        date: dateStr,
        running: latestOptimization.metrics.serviceTrains,
        standby: latestOptimization.metrics.standbyTrains,
        maintenance: latestOptimization.metrics.maintenanceTrains
      });
    } else if (actualData) {
      // Use actual data for historical dates
      historicalData.fleetDistributionTrend.push({
        date: dateStr,
        running: actualData.metrics.serviceTrains,
        standby: actualData.metrics.standbyTrains,
        maintenance: actualData.metrics.maintenanceTrains
      });
    } else {
      // Generate realistic synthetic data for dates without actual data
      const baseRunning = isPeakDay ? 18 : isWeekend ? 12 : 15;
      const baseStandby = isPeakDay ? 4 : isWeekend ? 8 : 6;
      const baseMaintenance = isPeakDay ? 3 : isWeekend ? 5 : 4;
      
      // Add realistic daily variation
      const dailyVariation = Math.sin(i / 7 * Math.PI * 2) * 2 + (Math.random() - 0.5) * 3;
      const maintenanceSpike = Math.random() < 0.1 ? 3 : 0; // Occasional maintenance spikes
      
      historicalData.fleetDistributionTrend.push({
        date: dateStr,
        running: Math.max(10, Math.min(22, Math.floor(baseRunning + dailyVariation))),
        standby: Math.max(2, Math.min(12, Math.floor(baseStandby - dailyVariation * 0.5))),
        maintenance: Math.max(1, Math.min(8, Math.floor(baseMaintenance + maintenanceSpike)))
      });
    }

    // Generate average score trend with more realistic patterns
    if (isToday && latestOptimization) {
      historicalData.averageScoreTrend.push({
        date: dateStr,
        score: latestOptimization.metrics.averageScore
      });
    } else {
      const scoreBase = isPeakDay ? 78 : isWeekend ? 72 : 75;
      const scoreVariation = Math.sin(i / 7 * Math.PI * 2) * 8 + Math.sin(i / 30 * Math.PI * 2) * 3 + (Math.random() - 0.5) * 6;
      historicalData.averageScoreTrend.push({
        date: dateStr,
        score: Math.max(60, Math.min(95, Math.round(scoreBase + scoreVariation)))
      });
    }

    // Generate branding compliance trend with realistic patterns
    if (isToday && latestOptimization) {
      historicalData.brandingComplianceTrend.push({
        date: dateStr,
        compliance: latestOptimization.metrics.brandingCompliance
      });
    } else {
      const brandingBase = 85 + Math.sin(i / 21 * Math.PI * 2) * 5; // Monthly cycle
      const brandingVariation = (Math.random() - 0.5) * 4;
      historicalData.brandingComplianceTrend.push({
        date: dateStr,
        compliance: Math.max(70, Math.min(100, Math.round(brandingBase + brandingVariation)))
      });
    }

    // Generate shunting cost trend with realistic patterns
    if (isToday && latestOptimization) {
      historicalData.shuntingCostTrend.push({
        date: dateStr,
        cost: latestOptimization.metrics.shuntingCost
      });
    } else {
      const costBase = isPeakDay ? 180 : isWeekend ? 120 : 150;
      const costVariation = Math.sin(i / 7 * Math.PI * 2) * 25 + Math.sin(i / 14 * Math.PI * 2) * 15 + (Math.random() - 0.5) * 20;
      historicalData.shuntingCostTrend.push({
        date: dateStr,
        cost: Math.max(80, Math.min(300, Math.floor(costBase + costVariation)))
      });
    }
  }

  return historicalData;
}

export default router;

